<template>
  <div class="flex h-screen bg-gray-900 text-white">
    <!-- Sidebar -->
    <div class="w-64 bg-gray-800 p-4 flex flex-col">
      <h1 class="text-2xl font-bold mb-4">MPPW-MCP</h1>
      <nav class="flex flex-col space-y-2">
        <router-link to="/" class="text-gray-300 hover:text-white"><i class="fas fa-home mr-2"></i>Home</router-link>
        <router-link to="/history" class="text-gray-300 hover:text-white"><i class="fas fa-history mr-2"></i>History</router-link>
        <router-link to="/docs" class="text-gray-300 hover:text-white"><i class="fas fa-book mr-2"></i>Docs</router-link>
      </nav>
      <div class="mt-auto">
        <div v-if="authStore.isAuthenticated" class="flex items-center">
          <span class="text-sm">Welcome, {{ authStore.isGuest ? 'Guest' : authStore.currentUser?.email }}</span>
          <button @click="handleLogout" class="ml-auto text-red-400 hover:text-red-300">
            <i class="fas fa-sign-out-alt"></i>
          </button>
        </div>
        <button v-else @click="handleSignIn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
          Sign In
        </button>
      </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 flex flex-col p-6 overflow-hidden">
      <!-- Input Area -->
      <div class="mb-4">
        <textarea
            v-model="naturalQuery"
            @keyup.enter="runPipeline('standard')"
            :disabled="isProcessing"
            class="w-full p-3 bg-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
            placeholder="Enter your natural language query here..."
        ></textarea>
        <div class="flex space-x-2 mt-2">
            <button @click="runPipeline('fast')" :disabled="isProcessing" class="btn-primary">
                <i class="fas fa-bolt mr-2"></i> Translate
            </button>
            <button @click="runPipeline('standard')" :disabled="isProcessing" class="btn-primary">
                <i class="fas fa-users-cog mr-2"></i> Multi-Agent
            </button>
            <button @click="runPipeline('comprehensive')" :disabled="isProcessing" class="btn-primary">
                <i class="fas fa-rocket mr-2"></i> Enhanced Agents
            </button>
        </div>
      </div>
      
      <!-- Results Area -->
      <div class="flex-1 grid grid-cols-1 lg:grid-cols-2 gap-6 overflow-hidden">
        <!-- Left Panel: Chat Stream -->
        <div class="flex flex-col overflow-hidden">
            <ChatStream :messages="chatMessages" :loading="isProcessing" title="Agent Stream" />
        </div>
        
        <!-- Right Panel: GraphQL and Data -->
        <div class="flex flex-col space-y-6 overflow-hidden">
            <GraphQLQueryBox :query="finalGraphQLQuery" @send="runDataQuery" />
            <DataResults :results="dataQueryResults" :loading="isDataLoading" />
        </div>
      </div>
    </div>
    
    <AuthModal :show="showAuthModal" @close="showAuthModal = false" @authenticated="onAuthenticated" @guest="onGuestSession" />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '../stores/auth';
import { useHistoryStore } from '../stores/history';
import AuthModal from '../components/AuthModal.vue';
import ChatStream from '../components/ChatStream.vue';
import GraphQLQueryBox from '../components/GraphQLQueryBox.vue';
import DataResults from '../components/DataResults.vue';

const authStore = useAuthStore();
const historyStore = useHistoryStore();
const router = useRouter();

const naturalQuery = ref('');
const chatMessages = ref<any[]>([]);
const isProcessing = ref(false);
const showAuthModal = ref(false);

const finalGraphQLQuery = ref('');
const isDataLoading = ref(false);
const dataQueryResults = ref<any[]>([]);

const runPipeline = async (strategy: string) => {
  if (!naturalQuery.value.trim() || isProcessing.value) return;

  console.log('üöÄ Starting pipeline with strategy:', strategy);
  isProcessing.value = true;
  chatMessages.value = [];
  finalGraphQLQuery.value = '';
  dataQueryResults.value = [];

  chatMessages.value.push({ role: 'user', content: naturalQuery.value, timestamp: new Date().toLocaleTimeString() });

  try {
    console.log('üì° Making request to /api/multiagent/process/stream');
    const response = await fetch('/api/multiagent/process/stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: naturalQuery.value, pipeline_strategy: strategy }),
    });

    console.log('üì• Response status:', response.status, 'headers:', Object.fromEntries(response.headers.entries()));

    if (!response.body) throw new Error("Response body is null");

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let eventCount = 0;

    console.log('üîÑ Starting to read stream...');
    while (true) {
        const { done, value } = await reader.read();
        if (done) {
          console.log('‚úÖ Stream complete, processed', eventCount, 'events');
          break;
        }

        const chunk = decoder.decode(value, { stream: true });
        console.log('üì¶ Raw chunk received:', chunk.length, 'bytes');
        console.log('üì¶ Raw chunk content:', JSON.stringify(chunk));
        buffer += chunk;
        
        // Handle both \r\n and \n line endings for SSE
        const eventMessages = buffer.split(/\r?\n\r?\n/);
        console.log('üîç Buffer after adding chunk:', JSON.stringify(buffer));
        console.log('üîç Split into', eventMessages.length, 'potential messages');
        buffer = eventMessages.pop() || '';

        console.log('üîç Processing', eventMessages.length, 'event messages');
        for (const msg of eventMessages) {
            console.log('üìù Processing message:', JSON.stringify(msg));
            console.log('üìù Raw message:', msg);
            const lines = msg.split(/\r?\n/);
            console.log('üìù Split into lines:', lines);
            let eventType = 'message';
            let dataStr = '';
            for (const line of lines) {
                if (line.startsWith('event:')) {
                    eventType = line.slice(6).trim();
                    console.log('üéØ Found event type:', eventType);
                } else if (line.startsWith('data:')) {
                    dataStr += line.slice(5).trim();
                    console.log('üéØ Found data line:', line.slice(5).trim());
                }
            }
            console.log('üéØ Parsed event type:', eventType, 'data length:', dataStr.length);
            if (!dataStr) {
              console.log('‚ö†Ô∏è No data found, skipping');
              continue;
            }
            try {
                const parsed = JSON.parse(dataStr);
                console.log('‚úÖ Successfully parsed SSE event:', parsed);
                eventCount++;
                handleStreamEvent(parsed);
            } catch (e) {
                console.error('‚ùå Failed to parse SSE data', dataStr, e);
            }
        }
    }
  } catch (error) {
    console.error('üí• Pipeline error:', error);
  } finally {
    console.log('üèÅ Pipeline finished, setting isProcessing to false');
    isProcessing.value = false;
  }
};

const handleStreamEvent = (event: any) => {
  console.log('üéÆ Handling stream event:', event);
  
  const eventType = event.event;
  const data = event.data || event;
  
  console.log('üìä Event type:', eventType, 'Event data:', data);
  
  switch (eventType) {
    case 'agent_start':
      console.log('üöÄ Agent starting:', data.agent);
      const startMessage = {
        role: 'agent',
        agent: data.agent,
        content: `Agent [${data.agent}] started...`,
        timestamp: new Date().toLocaleTimeString(),
        isStreaming: true,
      };
      chatMessages.value.push(startMessage);
      console.log('üí¨ Added start message, total messages:', chatMessages.value.length);
      break;
      
    case 'agent_token':
      console.log('üî§ Token received for agent:', data.agent, 'token:', data.token);
      const lastMessage = chatMessages.value[chatMessages.value.length - 1];
      if (lastMessage && lastMessage.agent === data.agent && lastMessage.isStreaming) {
        if (lastMessage.content.endsWith('...')) {
          lastMessage.content = `Agent [${data.agent}] says: `;
        }
        lastMessage.content += data.token;
        console.log('üìù Updated message content:', lastMessage.content);
      } else {
        console.log('‚ö†Ô∏è Could not find streaming message for agent:', data.agent);
      }
      break;
      
    case 'agent_complete':
      console.log('‚úÖ Agent completed:', data.agent, 'result:', data.result);
      const agentMessage = chatMessages.value.find(m => m.agent === data.agent && m.isStreaming);
      if (agentMessage) {
        agentMessage.isStreaming = false;
        if (data.agent === 'translator' && data.result?.graphql_query) {
          console.log('üîç Setting GraphQL query:', data.result.graphql_query);
          finalGraphQLQuery.value = data.result.graphql_query;
        }
        console.log('üí¨ Marked agent as completed, kept output');
      } else {
        console.log('‚ö†Ô∏è Could not find agent message for completion:', data.agent);
      }
      break;
      
    case 'pipeline_complete':
      console.log('üèÅ Pipeline completed, final data:', data);
      if (data.translation?.graphql_query && !finalGraphQLQuery.value) {
        console.log('üîç Setting GraphQL query from pipeline complete:', data.translation.graphql_query);
        finalGraphQLQuery.value = data.translation.graphql_query;
      }
      chatMessages.value.push({
        role: 'agent',
        agent: 'system',
        content: 'Pipeline completed.',
        timestamp: new Date().toLocaleTimeString(),
      });
      console.log('üí¨ Added pipeline complete message');
      break;
      
    case 'error':
      console.log('‚ùå Error event received:', data.error);
      chatMessages.value.push({
        role: 'agent',
        agent: 'system',
        content: `Error: ${data.error || 'Unknown error'}`,
        timestamp: new Date().toLocaleTimeString(),
      });
      console.log('üí¨ Added error message');
      break;
      
    default:
      console.log('‚ùì Unknown event type:', eventType);
  }
  
  console.log('üìä Current chat messages:', chatMessages.value);
  console.log('üîç Current GraphQL query:', finalGraphQLQuery.value);
};

const runDataQuery = async () => {
    if (!finalGraphQLQuery.value.trim()) return;
    isDataLoading.value = true;
    dataQueryResults.value = [];
    try {
        const response = await fetch('/api/data/query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: finalGraphQLQuery.value }),
        });
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to fetch data');
        }
        const results = await response.json();
        dataQueryResults.value = results.data;
    } catch (error) {
        console.error('Data query error:', error);
        dataQueryResults.value = [{ error: String(error) }];
    } finally {
        isDataLoading.value = false;
    }
}

// Auth Handlers
const handleSignIn = () => { showAuthModal.value = true; };
const handleLogout = () => { authStore.logout(); router.push('/'); };
const onAuthenticated = (authData: any) => { authStore.setAuthenticated(authData); showAuthModal.value = false; };
const onGuestSession = (sessionData: any) => { authStore.setGuestSession(sessionData); showAuthModal.value = false; };

// Lifecycle
onMounted(() => {
  authStore.loadPersistedSession();
});
</script>

<style scoped>
.btn-primary {
  @apply bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed;
}
</style>